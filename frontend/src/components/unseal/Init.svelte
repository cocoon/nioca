<script>
    import {extractFormErrors} from "../../utils/helpers.js";
    import Button from "$lib/Button.svelte";
    import PasswordInput from "$lib/inputs/PasswordInput.svelte";
    import {
        fetchUnsealXsrf,
        postInit,
        postInitCheck,
    } from "../../utils/dataFetchingUnseal.js";
    import * as yup from "yup";
    import {REGEX_INIT_KEY, REGEX_KEY_HEX} from "../../utils/constants.js";
    import X509Contents from "../x509/X509Contents.svelte";
    import Textarea from "$lib/inputs/Textarea.svelte";

    const inputWidth = '31rem';

    let isLoading = false;
    let isValidated = false;
    let checkRes;
    let disableProceed = true;
    let masterShards;

    let err = '';

    let formValues = {};
    let formErrors = {};

    const schema = yup.object().shape({
        rootPem: yup.string().required('Required').max(5000, 'Maximum length: 5000 characters'),
        intermediatePem: yup.string().required('Required').max(5000, 'Maximum length: 5000 characters'),
        intermediateKeyHex: yup.string().trim().matches(REGEX_KEY_HEX, 'Must be a valid HEX format'),
        localPassword: yup.string().required('Required').min(16, 'At least 16 characters').max(128, 'Maximum length: 128 characters'),
        keyPassword: yup.string().required('Required').max(1024, 'Maximum length: 1024 characters'),
        initKey: yup.string().trim().matches(REGEX_INIT_KEY, 'Nioca Init Key from log output'),
    });

    async function additionalValidation() {
        if (!formValues.rootPem.includes('-----BEGIN CERTIFICATE-----')
            || !formValues.rootPem.includes('-----END CERTIFICATE-----')) {
            formErrors.rootPem = 'Must be a valid PEM format';
            return false;
        }

        if (!formValues.intermediatePem.includes('-----BEGIN CERTIFICATE-----')
            || !formValues.intermediatePem.includes('-----END CERTIFICATE-----')) {
            formErrors.intermediatePem = 'Must be a valid PEM format';
            return false;
        }

        if (formValues.localPassword !== formValues.localPasswordConfirm) {
            formErrors.localPasswordConfirm = 'Local Passwords do not match';
            return false;
        }

        return true;
    }

    async function validate(op) {
        err = '';

        try {
            await schema.validate(formValues, {abortEarly: false});
            formErrors = {};
        } catch (err) {
            formErrors = extractFormErrors(err);
            return;
        }

        const isValid = await additionalValidation();
        if (!isValid) {
            return;
        }

        isLoading = true;

        const xsrfRes = await fetchUnsealXsrf();
        if (!xsrfRes.ok) {
            let body = await xsrfRes.json();
            err = body.message;
            return;
        }
        const xsrfKey = await xsrfRes.text();

        const data = {
            localPassword: formValues.localPassword,
            rootPem: formValues.rootPem,
            itPem: formValues.intermediatePem,
            itKey: formValues.intermediateKeyHex,
            itPassword: formValues.keyPassword,
            initKey: formValues.initKey,
            xsrfKey: xsrfKey,
        };

        isLoading = true;

        if (op === 'check') {
            const res = await postInitCheck(data);
            let body = await res.json();
            if (res.ok) {
                isValidated = true;
                checkRes = body;
            } else {
                err = body.message;
            }
        } else if (op === 'init') {
            const res = await postInit(data);
            let body = await res.json();
            if (res.ok) {
                masterShards = {
                    masterShard1: body.masterShard1,
                    masterShard2: body.masterShard2,
                };
                // enable the unseal button only after 5 seconds to avoid someone clicking too fast without copying
                // the master keys
                setTimeout(() => {
                    disableProceed = false;
                }, 5000);
            } else {
                err = body.message;
            }
        }

        isLoading = false;
    }
</script>

<div class="container">
    <div class="desc">
        <h1>Nioca has not been initialized</h1>

        Nioca has not been initialized yet.<br>
        You will do it on this page.<br><br>

        What you will need for the process:
        <ul>
            <li>Root Certificate in PEM format</li>
            <li>Intermediate Certificate in PEM format</li>
            <li>Intermediate Key in encrypted DER-HEX format<br> -> generated by the nioca cli tool</li>
            <li>Intermediate Key encryption password<br> -> set during bootstrap with the nioca cli tool</li>
            <li>Nioca Init Key<br> -> logged into the console at startup</li>
        </ul>
    </div>

    <!-- Root Cert PEM -->
    <Textarea
            rows=17
            name="rootPem"
            placeholder="Root Certificate in PEM format"
            bind:value={formValues.rootPem}
            bind:error={formErrors.rootPem}
    >
        Root Certificate in PEM format
    </Textarea>

    <!-- Intermediate Cert PEM -->
    <Textarea
            rows=17
            name="intermediatePem"
            placeholder="Intermediate Certificate in PEM format"
            bind:value={formValues.intermediatePem}
            bind:error={formErrors.intermediatePem}
    >
        Intermediate Certificate in PEM format
    </Textarea>

    <Textarea
            rows=12
            name="intermediateKeyHex"
            placeholder="Intermediate Key in encrypted PEM-HEX format"
            bind:value={formValues.intermediateKeyHex}
            bind:error={formErrors.intermediateKeyHex}
    >
        Intermediate Key in encrypted PEM-HEX format
    </Textarea>

    <div class="block">
        <!-- Intermediate Key encryption password -->
        <PasswordInput
                name="keyPassword"
                placeholder="Encryption Password"
                width={inputWidth}
                bind:value={formValues.keyPassword}
                bind:error={formErrors.keyPassword}
        >
            Intermediate Key encryption password
        </PasswordInput>

        <!-- Nioca Init Key -->
        <PasswordInput
                name="initKey"
                placeholder="Nioca Init Key"
                width={inputWidth}
                bind:value={formValues.initKey}
                bind:error={formErrors.initKey}
        >
            Nioca Init Key
        </PasswordInput>

        <!-- New local account password -->
        <PasswordInput
                name="localPassword"
                placeholder="New Local Password"
                width={inputWidth}
                bind:value={formValues.localPassword}
                bind:error={formErrors.localPassword}
        >
            New local account password
        </PasswordInput>

        <!-- New local account password confirm -->
        <PasswordInput
                name="localPasswordConfirm"
                placeholder="New Local Password Confirm"
                width={inputWidth}
                bind:value={formValues.localPasswordConfirm}
                bind:error={formErrors.localPasswordConfirm}
        >
            New local account password confirm
        </PasswordInput>
    </div>

    {#if !masterShards}
        <Button
                on:click={() => validate('check')}
                bind:isLoading
        >
            VALIDATE
        </Button>
    {/if}

    {#if checkRes}
        <div class="checkRes">
            <div class="checkCert">
                Root Certificate:
                <X509Contents cert={checkRes.root}/>
            </div>

            <div class="checkCert">
                Intermediate Certificate:
                <X509Contents cert={checkRes.intermediate}/>
            </div>
        </div>
    {/if}

    {#if isValidated}
        <div class="initNote">
            <div class="initNoteHeader">
                CAUTION
            </div>
            The initialization is not reversible!<br>
            After it has been successful, you will be shown the master keys.<br>
            <span class="bold">They will only appear once!</span><br><br>
            Copy them from this UI and save them somewhere really secure.<br>
            Without these keys, you will not be able to unseal Nioca.<br><br>
        </div>

        {#if !masterShards}
            <Button
                    on:click={() => validate('init')}
                    bind:isLoading
            >
                INITIALIZE
            </Button>
        {/if}
    {/if}

    {#if masterShards}
        <div class="keys">
            <PasswordInput
                    value={masterShards.masterShard1}
                    width={inputWidth}
                    showCopy
            >
                Master Key 1
            </PasswordInput>
            <PasswordInput
                    value={masterShards.masterShard2}
                    width={inputWidth}
                    showCopy
            >
                Master Key 2
            </PasswordInput>
        </div>

        <h3>Do not proceed without saving the Master Keys!</h3>
        <Button
                on:click={() => window.location.reload()}
                isLoading={disableProceed}
        >
            PROCEED
        </Button>
    {/if}

    {#if err}
        <div class="errMain">
            {err}
        </div>
    {/if}
</div>

<style>
    .block {
        margin: 10px 0;
    }

    .bold {
        font-weight: bold;
    }

    .checkCert {
        margin: 10px 0;
    }

    .checkRes {
        margin: 20px;
    }

    .container {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        margin-bottom: 30px;
    }

    .desc {
        width: 32rem;
    }

    .errMain {
        margin: 5px;
        color: var(--col-err);
        text-align: right;
    }

    .initNote {
        margin: 10px;
        padding: 10px;
    }

    .initNoteHeader {
        font-weight: bold;
        color: var(--col-err)
    }

    .keys {
        margin-top: 30px;
        margin-bottom: 20px;
    }
</style>
